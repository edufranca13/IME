#EP1 - MAT0210#Parte 1#Nome: Eduardo T. F. Hashimoto#n USP: 6514136#Testes do enunciado#2 + 3disp (sumieee('01000000000000000000000000000000', '01000000010000000000000000000000', 'up'));#resultado = 01000000101000000000000000000000#1 + 2^-24disp (sumieee('00111111100000000000000000000000', dec2ieee(2*2^-24), 'up'));#resultado = 00111111100000000000000000000011#computa a soma de dois números em formato ieee considerando o tipo de arredondamento dado#números de entrada são strings#round indica o tipo de arredondamento a ser usadofunction s = sumieee(x, y, arred)    xSignal = x(1);  #cálculo do expoente considerando o viés  xExp = bin2dec(x(2:9)) - 127;  xMant = x(10:end);      ySignal = y(1);  yExp = bin2dec(y(2:9)) - 127;  yMant = y(10:end);    #pega o sinal da maior mantissa no caso de os expoentes serem iguais  if (cstrcmp(xMant, yMant) == 1)    sSignal = xSignal;  else    sSignal = ySignal;  endif        xstickyBit = '0';  ystickyBit = '0';      #adiciona o bit escondido para fazer os cálculos  xMant = strcat('1', xMant);  yMant = strcat('1', yMant);    #alinhamento das mantissas e ajuste do expoente  #pega o sinal do maior expoente    while (xExp < yExp)    xExp += 1;    xMant = strcat('0', xMant);        #"liga" o sitcky bit caso tenha passado um 1 pelos guardas    if (length(xMant) > 25 && xMant(26) == '1')      xstickyBit = '1';    endif          #mantém a mantissa de y com mesmo tamanho que a de x    yMant = strcat(yMant, '0');        sSignal = ySignal;  endwhile  while (yExp < xExp)    yExp += 1;    yMant = strcat('0', yMant);        #"liga" o sitcky bit caso tenha passado um 1 pelos guardas    if (length(yMant) > 25 && yMant(26) == '1')      ystickyBit = '1';    endif        #mantém a mantissa de x com mesmo tamanho que a de y    xMant = strcat(xMant, '0');        sSignal = xSignal;  endwhile    mantLth = length(xMant);    #adiciona o sticky bit, caso ele apareça, a 26 casa da mantissa  if (xstickyBit == '1')    xMant(26) = '1';  endif  if (ystickyBit == '1')    yMant(26) = '1';  endif      sExp = xExp;  sMant = sumSequence(xMant, yMant, 1, max(24, min(26, mantLth)));      #arredondamento  if (length(sMant) > 23)    if (arred == 'up' && !isempty(findstr(sMant(24:end), '1')))      sMant(23) = '1';    endif  endif    #normalização do resultado  if (sMant(1) == 'c')    sMant = sMant (2:24);    sExp++;  else    sMant = sMant (2:24);  endif    sExp = dec2bin(127+sExp);    while (length(sExp) < 8)    sExp = strcat('0',sExp);  endwhile    s = strcat(sSignal, sExp, sMant);  endfunction#função auxiliar para somar bit a bitfunction sumb = sumbits (a, b, c)  if (a + b + c == 3)    sumb = [1 1];  elseif (a + b + c == 2)    sumb = [1 0];  elseif (a + b + c == 1)    sumb = [0 1];  else    sumb = [0 0];  endifendfunction#função auxiliar para somar sequências de bitsfunction sumS = sumSequence (num1, num2, startS, endS)  carryBit = 0;  sumS = "";    #usa sumbits em cada iteração  for i = startS : endS    partialSum = sumbits (str2num (num1 (startS + endS - i)), str2num (num2 (startS + endS - i)), carryBit);    carryBit = partialSum (1);    partialRes = num2str (partialSum (2));    sumS = strcat (partialRes, sumS);  endfor    #coloca um indicador para os casos em que o número precisa ser normalizado  if (carryBit != 0)    sumS = strcat ('c', sumS);  endif     endfunction#função auxiliar converte um número decimal em um número no formato ieee 32 bitsfunction ans = dec2ieee (number)  if (number > 0)    signal= '0';   else    signal = '1';   endif   pow = 0;   n = number;      while (n >= 2)    pow += 1;    n = number / 2^pow;   endwhile      while (n < 1)    pow -= 1;    n = number / 2^pow;   endwhile         exp = dec2bin(pow + 127);      while (length(exp) < 8)    exp = strcat ('0', exp);   endwhile      n = n - 1;   i = 0;   sig = "";      for i = 1 : 23    n = n*2;    if (n > 1)      n -= 1;      sig = strcat (sig, '1');    else      sig = strcat (sig, '0');    endif   endfor      ans = strcat(signal, exp, sig);  endfunction  #função auxiliar para comparar dois strings function cmp = cstrcmp( a, b )    x = char({a;b});    d = x(1,:) - x(2,:);    d(~d) = [];    if isempty(d)        cmp = 0;    else        cmp = d(1);    endend  