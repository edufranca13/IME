#EP1 - MAC0210#Nome: Eduardo Hashimoto#n USP: 6514136#função que gera a imagem da bacia de convergência de uma função ffunction matrix = newton_basis2(f, df, l, u, p, tol, nmax)    #vetor com as raizes  rootsArray = [];    #intervalos em que serão discretizados os pontos de partido  linterval = linspace(l(1),l(2), p(1));  uinterval = linspace(u(1),u(2), p(2));    for i = 1 : numel (linterval)    for j = 1: numel (uinterval)      #verifica se a raiz já foi encontrada anteriormente      root = newton(f, df, linterval(i) + uinterval(j), tol, nmax);      cv = find(rootsArray == root);      if (isempty(cv))        #se não, a adiciona ao vetor com as raízes com um número particular        #preenche a matrix com esse número        rootsArray = [rootsArray root];        matrix (i, j) = length(rootsArray);      else        #preenche a matrix com o número da raiz encontrada        matrix (i, j) = cv;      endif    endfor  endfor     #built-in que gera a imagem das bacias de convergência a partir da matrix   imagesc (matrix);   endfunction#função que implementa o método de newtonfunction ans = newton( f, df, x0, tol, nmax )        #as funções são passadas como strings (expressões) e lidas pela função inline    f = inline(f);    df = inline(df);    #aplicação do método de newton    x(1) = x0 - (f(x0)/df(x0));        ex(1) = abs(x(1)-x0);    k = 2;    while (ex(k-1) >= tol) && (k <= nmax)        x(k) = x(k-1) - (f(x(k-1))/df(x(k-1)));        ex(k) = abs(x(k)-x(k-1));        k = k+1;    endwhile          disp(x);    #não converge dentro da tolerancia fornecida - retorna 0    if (k > nmax)      ans = 'a';    #converge - retorna a raiz arredondada    else      ans = round(x(length(x)) * 100) /100;    endif    endfunctionnewton_basis2('x^4-1', '4*x^3', [-2 2], complex(0, [-2,2]), [200, 200], 0.5*10^-10, 1000);#newton_basis2('x^3-1', '3*x^2', [-2 2], complex(0, [-2,2]), [200, 200], 0.5*10^-10, 1000);